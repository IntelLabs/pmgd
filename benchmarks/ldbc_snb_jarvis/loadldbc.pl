#!/usr/bin/perl

# This script converts CSV files that follow a specific format into
# Jarvis Lake format. The input format is that generated by the LDBC
# database generator. The names of the input files comprise part of
# the input information.
#
# The input file names have one of the following two forms:
#     Node definition files: <node-tag>_<id>.csv
#     Edge definition files: <node-tag>_<relationship>_<node-tag>_<id>.csv
#
# The <node-tag> and <relationship> parts of the file name specify the
# types of entities defined or referenced in the file. In some cases,
# this information is repeated in the first line of the file, and in
# some cases it is only available from the file name. These strings are
# used as tags in the Jarvis Lake database. The file names should be all
# lower-case; node tags have the first character changed to upper case.
#
# The <id> part is numeric and is ignored. (It allows multiple input
# files defining the same types of nodes or edges.) The filename
# suffix of the input files must be "csv".
#
# If the --graph option is present, the result of the conversion is
# loaded directly into the specified database. The database must exist.
# Either the Jarvis Lake 'loadgraph' program must be in the path, or
# the --loadgraph option must be present, specifying the path to the
# loadgraph program.
#
# If the --graph option is not present, the result of the conversion
# is written to output files with the same names as the input files,
# but with the ".csv" suffix changed to ".j". If the --dir option is
# present, output files are created in the specified directory,
# otherwise they are created in the current directory.
#
# In a node definition file, the first line defines the names of the
# properties of each node. The first field must be "id". Subsequent
# fields may have any name. Each subsequent line of the file represents
# a node in the database. Node IDs must be numeric. Node IDs must be
# unique for nodes of the same type, but nodes of different types may
# have the same ID.
# For example, in the file "person_0", the first two lines might be:
#     id,firstName,lastName,birthday
#     8342,John,Doe,1982-04-15
#
# In an edge definition file, the first two fields of the first line
# repeat the node tags that are part of the file name, with a ".id"
# suffix added. This script checks that the node tags in the first line
# of the file match the corresponding parts of the file name.
# If there are additional fields on the first line, they define the names
# of properties of the edge. Each subsequent line of the file represents
# an edge in the database.
# For example, in the file "person_attend_university_0.csv", the first
# two lines might be:
#     Person.id,University.id,startYear,endYear
#     8342,13,1993,1997
#
# Property values may be numeric (integer decimal only), string, or
# ISO date or time. For date or time values the property name must
# contain the string birthday or Date.
#
# For best results, this script should be invoked with all relevant file
# names on a single invocation, so that it can identify all the necessary
# node tags.

use strict;
use warnings;
use integer;
use Getopt::Long;
use threads;

my @node_files = ();
my @edge_files = ();
my @node_tags = ();
my $sep = ',';
my $node_id_shift = 16;
my $graph = undef;
my $loadgraph = "loadgraph";
my $dir = "";

GetOptions("tag=s" => \@node_tags,
           "sep=s" => \$sep,
           "graph=s" => \$graph,
           "loadgraph=s" => \$loadgraph,
           "dir=s" => \$dir);

$sep = quotemeta($sep);

sub lookup_node_tag_id
{
    my $tagname = $_[0];
    my $n = 0;
    foreach (@node_tags) {
        $n++;
        return $n if (lc $_ eq $tagname);
    }
    return 0;
}

sub get_node_tag_id
{
    my $tagname = $_[0];
    my $id = lookup_node_tag_id($tagname);
    die "Unrecognized node tag \"$tagname\"" if ($id == 0);
    return $id;
}

sub get_node_id
{
    return $_[1] * $node_id_shift + $_[0];
}

sub get_language_id
{
    $_[0] =~ /(.)(.)/; # split two character string into two separate chars
    return ord($1) * 256 + ord($2);
}

# check all the input file names and assign numbers to tags
foreach my $infilename (@ARGV)
{
    my $inputname;
    my $node_tag;

    # Strip path from input file name.
    ($inputname = $infilename) =~ s/.*\///;

    # If this pattern matches, it is an edge definition file.
    if ($inputname =~ /^[^_]*_[^_]*_[^_]*_[^_]*$/) {
        push @edge_files, $infilename;
    }
    # If this pattern matches, it is an node definition file.
    elsif ( ($node_tag) = ($inputname =~ /^(.*)_([^_]*)$/) ) {
        if (lookup_node_tag_id($node_tag) == 0) {
            push @node_tags, ucfirst($node_tag)
        }
        push @node_files, $infilename;
    }
    else {
        die "Unrecognized file name pattern \"$inputname\"";
    }
}

# node_id_shift needs to be @node_tags + 1, because tag IDs
# are numbered from 1. So, for example, if there are 4 tags,
# numbered 1 - 4, then $node_id_shift needs to be 5. The
# minimum node_id_shift is 16, to make it /slightly/ easier
# to understand node IDs, if there aren't too many of them.
$node_id_shift = @node_tags + 1 unless @node_tags + 1 <= $node_id_shift;

my $result;
if (defined $graph) {
    open(my $out, "|-", "$loadgraph -j $graph -")
        or die "Error starting loadgraph";

    foreach (@node_files, @edge_files) {
        process_file($_, $out);
    }

    if (defined $out) {
        close $out or die "Error running loadgraph";
    }
    $result = 0;
}
else {
    # Append slash to dir if it isn't already present.
    $dir =~ s/[^\/]$/$&\//;
    mkdir $dir, 0777 if ! -d $dir;

    my @thread_list = ();
    foreach (@node_files, @edge_files) {
        my $t = threads->create(\&process_file, $_);
        push @thread_list, $t;
    }

    $result = 0;
    foreach (@thread_list) {
        my $r = $_->join();
        if (not defined $r or $r != 0) {
            $result = 1;
        }
    }
}

exit $result;


sub process_file
{
    my $infilename = $_[0];
    my $out = $_[1];
    my $inputname;
    my $outfilename;

    my $edge;

    my ($node_tag, $node_tag_id);
    my ($node1_tag, $node2_tag, $edge_tag);
    my ($node1_tag_id, $node2_tag_id);
    my $multi_value_property = 0;

    open(my $in, "<", $infilename) or die "Error opening $infilename";

    # Strip path from input file name.
    ($inputname = $infilename) =~ s/.*\///;

    # If this pattern matches, it is an edge definition file.
    my $n;
    if ( ($node1_tag, $edge_tag, $node2_tag, $n)
            = ($inputname =~ /^([^_]*)_([^_]*)_([^_]*)_([0-9]*)\.[^_]*$/) )
    {
        $edge = 1;
        $node1_tag_id = get_node_tag_id($node1_tag);
        $node1_tag = $node_tags[$node1_tag_id - 1];
        $node2_tag_id = get_node_tag_id($node2_tag);
        $node2_tag = $node_tags[$node2_tag_id - 1];
        print "$node1_tag $node2_tag $edge_tag ($n)\n";
    }
    # If this pattern matches, it is an node definition file.
    elsif ( ($node_tag, $n) = ($inputname =~ /^(.*)_([0-9]*)\.[^_]*$/) ) {
        $edge = 0;
        $node_tag_id = get_node_tag_id($node_tag);
        $node_tag = $node_tags[$node_tag_id - 1];
        print "$node_tag ($n)\n";
    }
    else {
        die "Unrecognized file name pattern \"$inputname\"";
    }

    my $line1 = <$in>;
    chomp($line1);
    my @property_names = split($sep, $line1);

    if ($edge) {
        $property_names[0] eq $node1_tag . ".id"
            or die "Property name mismatch in $infilename: " .
                   "$property_names[0] ne $node1_tag.id <$line1>";
        if ($property_names[1] eq $edge_tag) {
            $multi_value_property = 1;
            $property_names[1] = lc $node2_tag;
        }
        elsif ($property_names[1] eq lc $node2_tag) {
            $multi_value_property = 2;
        }
        else {
            $property_names[1] eq $node2_tag . ".id"
                or die "Property name mismatch in $infilename: ",
                       "\"$property_names[1]\" ne \"$node2_tag.id\": ",
                       "<$line1>";
        }
    }
    else {
        $property_names[0] eq "id"
            or die "Property name mismatch in $infilename: ",
                   "\"$property_names[0]\" ne \"id\": ",
                   "<$line1>";
    }

    my %hash = ();
    while (my $line = <$in>) {
        chomp $line;
        my @property_values = split($sep, $line);
        $#property_values == $#property_names
            or die "Wrong number of property values, ",
                   "$infilename, line $.";
        my $n;

        # The output file is opened here so that it is not created
        # if the input file is empty.
        if (not defined $out) {
            # Construct output file name.
            ($outfilename = $dir . $inputname) =~ s/\.csv$/\.j/;
            open($out, ">", $outfilename) or die "Error opening $outfilename";
        }

        if ($multi_value_property) {
            my $id;
            my $property = "";
            if ($multi_value_property == 1) {
                $id = 1;
                $n = 1;
                $property = "#$node2_tag";
            }
            else {
                if (exists $hash{$property_values[1]}) {
                    $id = $hash{$property_values[1]};
                }
                else {
                    $id = get_language_id($property_values[1]);
                    $hash{$property_values[1]} = $id;
                    $property = "#$node2_tag { $property_names[1] = \"$property_values[1]\" }";
                }
                $n = 2;
            }
            my $node1_id = get_node_id($node1_tag_id, $property_values[0]);
            my $node2_id = get_node_id($node2_tag_id, $id);
            print $out "$node1_id $node2_id $property : #$edge_tag";
        }
        elsif ($edge) {
            my $node1_id = get_node_id($node1_tag_id, $property_values[0]);
            my $node2_id = get_node_id($node2_tag_id, $property_values[1]);
            print $out "$node1_id $node2_id : #$edge_tag";
            $n = 2;
        }
        else {
            my $node_id = get_node_id($node_tag_id, $property_values[0]);
            print $out "$node_id #$node_tag";
            $n = 0;
        }
        if ($n <= $#property_names) {
            print $out " {";
            for my $p (@property_names[$n .. $#property_names]) {
                my $v = $property_values[$n++];
                if ($p eq "name" or ($p !~ /birthday|Date/ and $v !~ /^[0-9]+$/)) {
                    $v = "\"$v\"";
                }
                print $out " $p=$v";
            }
            print $out " }";
        }
        print $out ";\n";
    }

    close $in;
    if (not defined $_[1] and defined $out) {
        close $out or die "Error closing $outfilename";
    }
}
